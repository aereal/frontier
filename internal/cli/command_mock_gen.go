//go:build !live

// Code generated by MockGen. DO NOT EDIT.

package cli

import (
	context "context"
	io "io"
	reflect "reflect"

	frontier "github.com/aereal/frontier"
	gomock "go.uber.org/mock/gomock"
)

// MockDeployer is a mock of Deployer interface.
type MockDeployer struct {
	ctrl     *gomock.Controller
	recorder *MockDeployerMockRecorder
	isgomock struct{}
}

// MockDeployerMockRecorder is the mock recorder for MockDeployer.
type MockDeployerMockRecorder struct {
	mock *MockDeployer
}

// NewMockDeployer creates a new mock instance.
func NewMockDeployer(ctrl *gomock.Controller) *MockDeployer {
	mock := &MockDeployer{ctrl: ctrl}
	mock.recorder = &MockDeployerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeployer) EXPECT() *MockDeployerMockRecorder {
	return m.recorder
}

// Deploy mocks base method.
func (m *MockDeployer) Deploy(ctx context.Context, configPath string, publish bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Deploy", ctx, configPath, publish)
	ret0, _ := ret[0].(error)
	return ret0
}

// Deploy indicates an expected call of Deploy.
func (mr *MockDeployerMockRecorder) Deploy(ctx, configPath, publish any) *MockDeployerDeployCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deploy", reflect.TypeOf((*MockDeployer)(nil).Deploy), ctx, configPath, publish)
	return &MockDeployerDeployCall{Call: call}
}

// MockDeployerDeployCall wrap *gomock.Call
type MockDeployerDeployCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployerDeployCall) Return(arg0 error) *MockDeployerDeployCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployerDeployCall) Do(f func(context.Context, string, bool) error) *MockDeployerDeployCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployerDeployCall) DoAndReturn(f func(context.Context, string, bool) error) *MockDeployerDeployCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockImporter is a mock of Importer interface.
type MockImporter struct {
	ctrl     *gomock.Controller
	recorder *MockImporterMockRecorder
	isgomock struct{}
}

// MockImporterMockRecorder is the mock recorder for MockImporter.
type MockImporterMockRecorder struct {
	mock *MockImporter
}

// NewMockImporter creates a new mock instance.
func NewMockImporter(ctrl *gomock.Controller) *MockImporter {
	mock := &MockImporter{ctrl: ctrl}
	mock.recorder = &MockImporterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockImporter) EXPECT() *MockImporterMockRecorder {
	return m.recorder
}

// Import mocks base method.
func (m *MockImporter) Import(ctx context.Context, functionName string, configStream io.Writer, functionStream *frontier.WritableFile) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Import", ctx, functionName, configStream, functionStream)
	ret0, _ := ret[0].(error)
	return ret0
}

// Import indicates an expected call of Import.
func (mr *MockImporterMockRecorder) Import(ctx, functionName, configStream, functionStream any) *MockImporterImportCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Import", reflect.TypeOf((*MockImporter)(nil).Import), ctx, functionName, configStream, functionStream)
	return &MockImporterImportCall{Call: call}
}

// MockImporterImportCall wrap *gomock.Call
type MockImporterImportCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockImporterImportCall) Return(arg0 error) *MockImporterImportCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockImporterImportCall) Do(f func(context.Context, string, io.Writer, *frontier.WritableFile) error) *MockImporterImportCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockImporterImportCall) DoAndReturn(f func(context.Context, string, io.Writer, *frontier.WritableFile) error) *MockImporterImportCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRenderer is a mock of Renderer interface.
type MockRenderer struct {
	ctrl     *gomock.Controller
	recorder *MockRendererMockRecorder
	isgomock struct{}
}

// MockRendererMockRecorder is the mock recorder for MockRenderer.
type MockRendererMockRecorder struct {
	mock *MockRenderer
}

// NewMockRenderer creates a new mock instance.
func NewMockRenderer(ctrl *gomock.Controller) *MockRenderer {
	mock := &MockRenderer{ctrl: ctrl}
	mock.recorder = &MockRendererMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRenderer) EXPECT() *MockRendererMockRecorder {
	return m.recorder
}

// Render mocks base method.
func (m *MockRenderer) Render(ctx context.Context, configPath string, output io.Writer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Render", ctx, configPath, output)
	ret0, _ := ret[0].(error)
	return ret0
}

// Render indicates an expected call of Render.
func (mr *MockRendererMockRecorder) Render(ctx, configPath, output any) *MockRendererRenderCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Render", reflect.TypeOf((*MockRenderer)(nil).Render), ctx, configPath, output)
	return &MockRendererRenderCall{Call: call}
}

// MockRendererRenderCall wrap *gomock.Call
type MockRendererRenderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRendererRenderCall) Return(arg0 error) *MockRendererRenderCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRendererRenderCall) Do(f func(context.Context, string, io.Writer) error) *MockRendererRenderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRendererRenderCall) DoAndReturn(f func(context.Context, string, io.Writer) error) *MockRendererRenderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
