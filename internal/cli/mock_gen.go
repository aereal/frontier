//go:build !live

// Code generated by MockGen. DO NOT EDIT.

package cli

import (
	context "context"
	io "io"
	reflect "reflect"

	frontier "github.com/aereal/frontier"
	listdist "github.com/aereal/frontier/controller/listdist"
	fnarn "github.com/aereal/frontier/internal/fnarn"
	gomock "go.uber.org/mock/gomock"
)

// MockDeployController is a mock of DeployController interface.
type MockDeployController struct {
	ctrl     *gomock.Controller
	recorder *MockDeployControllerMockRecorder
	isgomock struct{}
}

// MockDeployControllerMockRecorder is the mock recorder for MockDeployController.
type MockDeployControllerMockRecorder struct {
	mock *MockDeployController
}

// NewMockDeployController creates a new mock instance.
func NewMockDeployController(ctrl *gomock.Controller) *MockDeployController {
	mock := &MockDeployController{ctrl: ctrl}
	mock.recorder = &MockDeployControllerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeployController) EXPECT() *MockDeployControllerMockRecorder {
	return m.recorder
}

// Deploy mocks base method.
func (m *MockDeployController) Deploy(ctx context.Context, configPath string, publish bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Deploy", ctx, configPath, publish)
	ret0, _ := ret[0].(error)
	return ret0
}

// Deploy indicates an expected call of Deploy.
func (mr *MockDeployControllerMockRecorder) Deploy(ctx, configPath, publish any) *MockDeployControllerDeployCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deploy", reflect.TypeOf((*MockDeployController)(nil).Deploy), ctx, configPath, publish)
	return &MockDeployControllerDeployCall{Call: call}
}

// MockDeployControllerDeployCall wrap *gomock.Call
type MockDeployControllerDeployCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployControllerDeployCall) Return(arg0 error) *MockDeployControllerDeployCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployControllerDeployCall) Do(f func(context.Context, string, bool) error) *MockDeployControllerDeployCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployControllerDeployCall) DoAndReturn(f func(context.Context, string, bool) error) *MockDeployControllerDeployCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockImportController is a mock of ImportController interface.
type MockImportController struct {
	ctrl     *gomock.Controller
	recorder *MockImportControllerMockRecorder
	isgomock struct{}
}

// MockImportControllerMockRecorder is the mock recorder for MockImportController.
type MockImportControllerMockRecorder struct {
	mock *MockImportController
}

// NewMockImportController creates a new mock instance.
func NewMockImportController(ctrl *gomock.Controller) *MockImportController {
	mock := &MockImportController{ctrl: ctrl}
	mock.recorder = &MockImportControllerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockImportController) EXPECT() *MockImportControllerMockRecorder {
	return m.recorder
}

// Import mocks base method.
func (m *MockImportController) Import(ctx context.Context, functionName string, configStream io.Writer, functionStream *frontier.WritableFile) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Import", ctx, functionName, configStream, functionStream)
	ret0, _ := ret[0].(error)
	return ret0
}

// Import indicates an expected call of Import.
func (mr *MockImportControllerMockRecorder) Import(ctx, functionName, configStream, functionStream any) *MockImportControllerImportCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Import", reflect.TypeOf((*MockImportController)(nil).Import), ctx, functionName, configStream, functionStream)
	return &MockImportControllerImportCall{Call: call}
}

// MockImportControllerImportCall wrap *gomock.Call
type MockImportControllerImportCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockImportControllerImportCall) Return(arg0 error) *MockImportControllerImportCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockImportControllerImportCall) Do(f func(context.Context, string, io.Writer, *frontier.WritableFile) error) *MockImportControllerImportCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockImportControllerImportCall) DoAndReturn(f func(context.Context, string, io.Writer, *frontier.WritableFile) error) *MockImportControllerImportCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRenderController is a mock of RenderController interface.
type MockRenderController struct {
	ctrl     *gomock.Controller
	recorder *MockRenderControllerMockRecorder
	isgomock struct{}
}

// MockRenderControllerMockRecorder is the mock recorder for MockRenderController.
type MockRenderControllerMockRecorder struct {
	mock *MockRenderController
}

// NewMockRenderController creates a new mock instance.
func NewMockRenderController(ctrl *gomock.Controller) *MockRenderController {
	mock := &MockRenderController{ctrl: ctrl}
	mock.recorder = &MockRenderControllerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRenderController) EXPECT() *MockRenderControllerMockRecorder {
	return m.recorder
}

// Render mocks base method.
func (m *MockRenderController) Render(ctx context.Context, configPath string, output io.Writer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Render", ctx, configPath, output)
	ret0, _ := ret[0].(error)
	return ret0
}

// Render indicates an expected call of Render.
func (mr *MockRenderControllerMockRecorder) Render(ctx, configPath, output any) *MockRenderControllerRenderCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Render", reflect.TypeOf((*MockRenderController)(nil).Render), ctx, configPath, output)
	return &MockRenderControllerRenderCall{Call: call}
}

// MockRenderControllerRenderCall wrap *gomock.Call
type MockRenderControllerRenderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRenderControllerRenderCall) Return(arg0 error) *MockRenderControllerRenderCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRenderControllerRenderCall) Do(f func(context.Context, string, io.Writer) error) *MockRenderControllerRenderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRenderControllerRenderCall) DoAndReturn(f func(context.Context, string, io.Writer) error) *MockRenderControllerRenderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockListDistributionsController is a mock of ListDistributionsController interface.
type MockListDistributionsController struct {
	ctrl     *gomock.Controller
	recorder *MockListDistributionsControllerMockRecorder
	isgomock struct{}
}

// MockListDistributionsControllerMockRecorder is the mock recorder for MockListDistributionsController.
type MockListDistributionsControllerMockRecorder struct {
	mock *MockListDistributionsController
}

// NewMockListDistributionsController creates a new mock instance.
func NewMockListDistributionsController(ctrl *gomock.Controller) *MockListDistributionsController {
	mock := &MockListDistributionsController{ctrl: ctrl}
	mock.recorder = &MockListDistributionsControllerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockListDistributionsController) EXPECT() *MockListDistributionsControllerMockRecorder {
	return m.recorder
}

// ListDistributions mocks base method.
func (m *MockListDistributionsController) ListDistributions(ctx context.Context, output io.Writer, criteria *listdist.Criteria) ([]frontier.FunctionAssociation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDistributions", ctx, output, criteria)
	ret0, _ := ret[0].([]frontier.FunctionAssociation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListDistributions indicates an expected call of ListDistributions.
func (mr *MockListDistributionsControllerMockRecorder) ListDistributions(ctx, output, criteria any) *MockListDistributionsControllerListDistributionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDistributions", reflect.TypeOf((*MockListDistributionsController)(nil).ListDistributions), ctx, output, criteria)
	return &MockListDistributionsControllerListDistributionsCall{Call: call}
}

// MockListDistributionsControllerListDistributionsCall wrap *gomock.Call
type MockListDistributionsControllerListDistributionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockListDistributionsControllerListDistributionsCall) Return(arg0 []frontier.FunctionAssociation, arg1 error) *MockListDistributionsControllerListDistributionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockListDistributionsControllerListDistributionsCall) Do(f func(context.Context, io.Writer, *listdist.Criteria) ([]frontier.FunctionAssociation, error)) *MockListDistributionsControllerListDistributionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockListDistributionsControllerListDistributionsCall) DoAndReturn(f func(context.Context, io.Writer, *listdist.Criteria) ([]frontier.FunctionAssociation, error)) *MockListDistributionsControllerListDistributionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockFunctionARNResolver is a mock of FunctionARNResolver interface.
type MockFunctionARNResolver struct {
	ctrl     *gomock.Controller
	recorder *MockFunctionARNResolverMockRecorder
	isgomock struct{}
}

// MockFunctionARNResolverMockRecorder is the mock recorder for MockFunctionARNResolver.
type MockFunctionARNResolverMockRecorder struct {
	mock *MockFunctionARNResolver
}

// NewMockFunctionARNResolver creates a new mock instance.
func NewMockFunctionARNResolver(ctrl *gomock.Controller) *MockFunctionARNResolver {
	mock := &MockFunctionARNResolver{ctrl: ctrl}
	mock.recorder = &MockFunctionARNResolverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFunctionARNResolver) EXPECT() *MockFunctionARNResolverMockRecorder {
	return m.recorder
}

// ResolveFunctionARN mocks base method.
func (m *MockFunctionARNResolver) ResolveFunctionARN(ctx context.Context, identifier fnarn.FunctionIdentifier) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveFunctionARN", ctx, identifier)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveFunctionARN indicates an expected call of ResolveFunctionARN.
func (mr *MockFunctionARNResolverMockRecorder) ResolveFunctionARN(ctx, identifier any) *MockFunctionARNResolverResolveFunctionARNCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveFunctionARN", reflect.TypeOf((*MockFunctionARNResolver)(nil).ResolveFunctionARN), ctx, identifier)
	return &MockFunctionARNResolverResolveFunctionARNCall{Call: call}
}

// MockFunctionARNResolverResolveFunctionARNCall wrap *gomock.Call
type MockFunctionARNResolverResolveFunctionARNCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFunctionARNResolverResolveFunctionARNCall) Return(arg0 string, arg1 error) *MockFunctionARNResolverResolveFunctionARNCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFunctionARNResolverResolveFunctionARNCall) Do(f func(context.Context, fnarn.FunctionIdentifier) (string, error)) *MockFunctionARNResolverResolveFunctionARNCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFunctionARNResolverResolveFunctionARNCall) DoAndReturn(f func(context.Context, fnarn.FunctionIdentifier) (string, error)) *MockFunctionARNResolverResolveFunctionARNCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
