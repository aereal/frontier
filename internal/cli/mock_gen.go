//go:build !live

// Code generated by MockGen. DO NOT EDIT.

package cli

import (
	context "context"
	io "io"
	reflect "reflect"

	frontier "github.com/aereal/frontier"
	gomock "go.uber.org/mock/gomock"
)

// MockDeployController is a mock of DeployController interface.
type MockDeployController struct {
	ctrl     *gomock.Controller
	recorder *MockDeployControllerMockRecorder
	isgomock struct{}
}

// MockDeployControllerMockRecorder is the mock recorder for MockDeployController.
type MockDeployControllerMockRecorder struct {
	mock *MockDeployController
}

// NewMockDeployController creates a new mock instance.
func NewMockDeployController(ctrl *gomock.Controller) *MockDeployController {
	mock := &MockDeployController{ctrl: ctrl}
	mock.recorder = &MockDeployControllerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeployController) EXPECT() *MockDeployControllerMockRecorder {
	return m.recorder
}

// Deploy mocks base method.
func (m *MockDeployController) Deploy(ctx context.Context, configPath string, publish bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Deploy", ctx, configPath, publish)
	ret0, _ := ret[0].(error)
	return ret0
}

// Deploy indicates an expected call of Deploy.
func (mr *MockDeployControllerMockRecorder) Deploy(ctx, configPath, publish any) *MockDeployControllerDeployCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deploy", reflect.TypeOf((*MockDeployController)(nil).Deploy), ctx, configPath, publish)
	return &MockDeployControllerDeployCall{Call: call}
}

// MockDeployControllerDeployCall wrap *gomock.Call
type MockDeployControllerDeployCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployControllerDeployCall) Return(arg0 error) *MockDeployControllerDeployCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployControllerDeployCall) Do(f func(context.Context, string, bool) error) *MockDeployControllerDeployCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployControllerDeployCall) DoAndReturn(f func(context.Context, string, bool) error) *MockDeployControllerDeployCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockImportController is a mock of ImportController interface.
type MockImportController struct {
	ctrl     *gomock.Controller
	recorder *MockImportControllerMockRecorder
	isgomock struct{}
}

// MockImportControllerMockRecorder is the mock recorder for MockImportController.
type MockImportControllerMockRecorder struct {
	mock *MockImportController
}

// NewMockImportController creates a new mock instance.
func NewMockImportController(ctrl *gomock.Controller) *MockImportController {
	mock := &MockImportController{ctrl: ctrl}
	mock.recorder = &MockImportControllerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockImportController) EXPECT() *MockImportControllerMockRecorder {
	return m.recorder
}

// Import mocks base method.
func (m *MockImportController) Import(ctx context.Context, functionName string, configStream io.Writer, functionStream *frontier.WritableFile) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Import", ctx, functionName, configStream, functionStream)
	ret0, _ := ret[0].(error)
	return ret0
}

// Import indicates an expected call of Import.
func (mr *MockImportControllerMockRecorder) Import(ctx, functionName, configStream, functionStream any) *MockImportControllerImportCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Import", reflect.TypeOf((*MockImportController)(nil).Import), ctx, functionName, configStream, functionStream)
	return &MockImportControllerImportCall{Call: call}
}

// MockImportControllerImportCall wrap *gomock.Call
type MockImportControllerImportCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockImportControllerImportCall) Return(arg0 error) *MockImportControllerImportCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockImportControllerImportCall) Do(f func(context.Context, string, io.Writer, *frontier.WritableFile) error) *MockImportControllerImportCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockImportControllerImportCall) DoAndReturn(f func(context.Context, string, io.Writer, *frontier.WritableFile) error) *MockImportControllerImportCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRenderController is a mock of RenderController interface.
type MockRenderController struct {
	ctrl     *gomock.Controller
	recorder *MockRenderControllerMockRecorder
	isgomock struct{}
}

// MockRenderControllerMockRecorder is the mock recorder for MockRenderController.
type MockRenderControllerMockRecorder struct {
	mock *MockRenderController
}

// NewMockRenderController creates a new mock instance.
func NewMockRenderController(ctrl *gomock.Controller) *MockRenderController {
	mock := &MockRenderController{ctrl: ctrl}
	mock.recorder = &MockRenderControllerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRenderController) EXPECT() *MockRenderControllerMockRecorder {
	return m.recorder
}

// Render mocks base method.
func (m *MockRenderController) Render(ctx context.Context, configPath string, output io.Writer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Render", ctx, configPath, output)
	ret0, _ := ret[0].(error)
	return ret0
}

// Render indicates an expected call of Render.
func (mr *MockRenderControllerMockRecorder) Render(ctx, configPath, output any) *MockRenderControllerRenderCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Render", reflect.TypeOf((*MockRenderController)(nil).Render), ctx, configPath, output)
	return &MockRenderControllerRenderCall{Call: call}
}

// MockRenderControllerRenderCall wrap *gomock.Call
type MockRenderControllerRenderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRenderControllerRenderCall) Return(arg0 error) *MockRenderControllerRenderCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRenderControllerRenderCall) Do(f func(context.Context, string, io.Writer) error) *MockRenderControllerRenderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRenderControllerRenderCall) DoAndReturn(f func(context.Context, string, io.Writer) error) *MockRenderControllerRenderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
